# Disaster Recovery

As we have seen, the strength of GitOps is the ability to mange application workloads and move applications between clusters.

Through the use of overlays, GitoOps can be used to provide `Disaster Recovery` solutions for our applications.

In this lab we are going to see how GitOps along with our MongoDB cluster manages a failure of the primary MongoDB Replica.

## Creating some chaos
We are going to delete the deployment and the persistent volume claim within cluster1.

~~~sh
oc delete pvc --context cluster1 -n mongo mongo
oc delete deployment --context cluster1 -n mongo mongo
~~~

The above command states that there should be 0 replicas in cluster1. To verify
no pods are running the following command can be ran.

> **NOTE:** It is possible that you see the pod in terminating status, that's fine.

When running this commmand. The output should show no resources are defined.
~~~sh
oc --context=cluster1 -n mongo get deployment
~~~

Let's go ahead and remove the storage for MongoDB from `cluster1`:

## Verifying Pacman Application still works

We have lost our primary MongoDB replica, but that didn't impact our application at all. Since we have three MongoDB replicas, the Pacman application can continue saving and reading high scores from the database.

You can go ahead and play Pacman, verify that high scores are saved.

## Bring the MongoDB replica back

Our engineers have been working hard during the weekend, we are ready to bring MongoDB replica on cluster1 back to life.

We will now sync the app which will recreate the storage and redeploy the Mongo Replica
~~~sh
argocd app sync cluster1-mongo
~~~

We should see our MongoDB pod being created:

~~~sh 
oc --context=cluster1 -n mongo get pods

NAME                     READY   STATUS              RESTARTS   AGE
mongo-5f9ff55b67-5bgtc   0/1     ContainerCreating   0          8s
~~~

Once the pod is running the MongoDB replica will be reconfigured, we can get the new primary and secondary members by running:

~~~sh
wait-for-deployment cluster1 mongo mongo
MONGO_POD=$(oc --context=cluster1 -n mongo get pod --selector="name=mongo" --output=jsonpath='{.items..metadata.name}')
REPLICASET_STATUS=$(oc --context=cluster1 -n mongo exec $MONGO_POD -- bash -c 'mongo --norc --quiet --username=admin --password=$MONGODB_ADMIN_PASSWORD --host localhost admin --tls --tlsCAFile /opt/mongo-ssl/ca.pem --eval "JSON.stringify(rs.status())"')
# Get Primary Member
echo $REPLICASET_STATUS | jq '.members[] | select(.state | contains(1)).name'
# Get Secondary Members
echo $REPLICASET_STATUS | jq '.members[] | select(.state | contains(2)).name'
~~~

That concludes the disaster recovery lab.

Next Lab: [Lab 11 - Wrapup](./11.md)<br>
Previous Lab: [Lab 9 - Canary Deployments](./9.md)<br>
[Home](./README.md)
