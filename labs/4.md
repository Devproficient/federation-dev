<a id="markdown-example-application" name="example-application"></a>
# Federate our First Application - NGINX

Now that we have federation installed, letâ€™s deploy an example app in the
clusters through the KubeFed Control Plane. In this exercise, we will only use two out of the three clusters that are part of the KubeFed Control Plane.

The `test-namespace` namespace must be created and then defined as a federated namespace.
~~~sh
oc --context=cluster1 create ns test-namespace
kubefedctl federate namespace test-namespace --host-cluster-context cluster1
~~~

Verify that our test-namespace is present in the two clusters now:

~~~sh
for cluster in cluster1 cluster2; do
  oc --context=${cluster} get ns test-namespace
done

NAME             STATUS   AGE
test-namespace   Active   28s
NAME             STATUS   AGE
test-namespace   Active   28s
~~~

<a id="markdown-deploy-the-application" name="deploy-the-application"></a>
## Deploy the application

The sample application we are using is a NGINX web server serving a default index page.

The sample application includes the following resources:

-   A [Deployment](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/) of an NGINX web server.
-   A [Service](https://kubernetes.io/docs/concepts/services-networking/service/) of type NodePort for NGINX.
-   A sample [ConfigMap](https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/), [Secret](https://kubernetes.io/docs/concepts/configuration/secret/) and [ServiceAccount](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/). These are not actually used by
    the sample application (static NGINX) but are included to illustrate how
    KubeFed would assist with more complex applications.

The [sample-app directory](../sample-clusterscoped/) contains definitions to deploy these resources. For each of them there is a resource template and a placement policy, and some of
them also have overrides. For example: the [sample NGINX deployment template](../sample-clusterscoped/federateddeployment.yaml)
specifies 3 replicas, but there is also an override that sets the replicas to 5
on `cluster2`.

Instantiate all these federated resources:

~~~sh
cd ~/federation-dev/
oc --context=cluster1 -n test-namespace apply -R -f sample-clusterscoped/
~~~

<a id="markdown-verify-that-the-application-is-running" name="verify-that-the-application-is-running"></a>
## Verify that the application is running

Verify that the various resources have been deployed in both clusters according
to their respective placement policies and cluster overrides:

~~~sh
for resource in configmaps secrets deployments services pods; do
    for cluster in cluster1 cluster2; do
        echo ------------ ${cluster} ${resource} ------------
        oc --context=${cluster} -n test-namespace get ${resource}
    done
done
~~~

We are going to wait until `test-deployment` is ready on both clusters, then we will expose the service so an OpenShift Route is created. We will use the created route to verify that the application can be accessed.

> **NOTE:** 200 OK reply mean that the connection has been successfully processed by the webserver

~~~sh
for cluster in cluster1 cluster2; do
  echo ------------ ${cluster} ------------
  # Wait for deployment to be ready
  wait-for-deployment ${cluster} test-namespace test-deployment
  # Expose the service so an OpenShift Route is created
  oc --context=${cluster} -n test-namespace expose service test-service
  sleep 2
  # Get Route hostname
  url="http://$(oc --context=${cluster} -n test-namespace get route test-service -o jsonpath='{.spec.host}')"
  # Access the route
  curl -I $url
done
~~~

<a id="markdown-modify-placement" name="modify-placement"></a>
## Modify placement

We are going to modify the federated deployment placement policy for the `test-deployment` we created before.

With below modification, `test-deployment` will be removed from `cluster2`, leaving it only active on `cluster1`:

~~~sh
oc --context=cluster1 -n test-namespace patch federateddeployment test-deployment \
    --type=merge -p '{"spec":{"placement":{"clusters": [{"name":"cluster1"}]}}}'
~~~

Observe how the federated deployment is now only present in `cluster1`:

> **NOTE:** No resources found in cluster2 is the expected behavior since we moved the workload away from that cluster

~~~sh
for cluster in cluster1 cluster2; do
    echo ------------ ${cluster} deployments ------------
    oc --context=${cluster} -n test-namespace get deployments
done
~~~

Keep in mind that we only moved the `FederatedDeployment`, this means that all other resources like `FederatedService`, `FederatedConfigMap`, etc. are still present in `cluster2`.

Now add `cluster2` back to the federated deployment placement:

~~~sh
oc --context=cluster1 -n test-namespace patch federateddeployment test-deployment \
    --type=merge -p '{"spec":{"placement":{"clusters": [{"name":"cluster1"}, {"name":"cluster2"}]}}}'
~~~

And verify that the federated deployment was deployed on both clusters again:

~~~sh
for cluster in cluster1 cluster2; do
    echo ------------ ${cluster} deployments ------------
    oc --context=${cluster} -n test-namespace get deployments
done
~~~

If a mistake was made, please let an instructor know, and review the [cleanup instructions](./cleanup-instructions.md).

Next Lab: [Lab 5 - Deploying MongoDB](./5.md)<br>
Previous Lab: [Lab 3 - Deploy Cluster Scoped Federation](./3.md)<br>
[Home](./README.md)